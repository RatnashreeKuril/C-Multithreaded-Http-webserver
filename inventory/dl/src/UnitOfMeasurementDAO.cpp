#include<stdio.h>#include<sqlite3.h>#include<dl/iuom>#include<dl/uom>#include<dl/daoexception>#include<dl/iuomdao>#include<dl/uomdao>#include<common/stringutils>#include<string.h>using namespace inventory;using namespace data_layer;using namespace stringutils;int countHandler(void *x, int columnCount, char ** dataPtr, char **columnNamePtr){int e=0;int *count=(int *)x;*count=0;char *c;int i=0;c=dataPtr[e];while(c[i]!='\0'){*count=(int)(c[i]-48)+((*count)*10);i++;}return 0;}int dataHandler(void *x, int columnCount, char ** dataPtr, char **columnNamePtr){abc::IUnitOfMeasurement *unitOfMeasurement=(abc::IUnitOfMeasurement *)x;int code=0;char *c;int i=0;string title;int e;for(e=0;e<columnCount;e++){if(compareStringIgnoreCase(string(columnNamePtr[e]).c_str(),string("code").c_str())==0){if(dataPtr[e]==NULL) code=0;else {c=dataPtr[e];while(c[i]!='\0'){code=(int)(c[i]-48)+(code*10);i++;}}}else{if(dataPtr[e]==NULL) title=string("");else title=dataPtr[e];}}unitOfMeasurement->setCode(code);unitOfMeasurement->setTitle(title);return 0;}int rowHandler(void *x, int columnCount, char ** dataPtr, char **columnNamePtr){int e;forward_list<abc::IUnitOfMeasurement *>* list=(forward_list<abc::IUnitOfMeasurement *> *)x;abc::IUnitOfMeasurement *unitOfMeasurement;int code=0;char *c;int i=0;string title;for(e=0;e<columnCount;e++){if(compareStringIgnoreCase(string(columnNamePtr[e]).c_str(),string("code").c_str())==0){c=dataPtr[e];while(c[i]!='\0'){code=(int)(c[i]-48)+(code*10);i++;}}else title=dataPtr[e];}unitOfMeasurement=new UnitOfMeasurement;unitOfMeasurement->setCode(code);unitOfMeasurement->setTitle(title);list->push_front(unitOfMeasurement);return 0;}void UnitOfMeasurementDAO::add(abc::IUnitOfMeasurement * unitOfMeasurement) throw(DAOException){const string vTitle=unitOfMeasurement->getTitle();string title=trimmed(vTitle);if(title.length()==0){throw DAOException("Title required, length is zero");}if(title.length()>50){throw DAOException("Title length cannot exceed 50");}sqlite3 *db;char sql[1001];char arr[101];char *errorMessage=NULL;int result=sqlite3_open("uom.db",&db);if(result!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}sprintf(sql,"insert into UnitOfMeasurement(title) values('%s');",title.c_str());result=sqlite3_exec(db,sql,NULL,NULL,&errorMessage);if(result!=SQLITE_OK){sprintf(arr,"Unable to insert record reason : %s\n",errorMessage);sqlite3_free(errorMessage);sqlite3_close(db);throw DAOException(string(arr));}int code=sqlite3_last_insert_rowid(db);unitOfMeasurement->setCode(code);sqlite3_close(db);}void UnitOfMeasurementDAO::update(abc::IUnitOfMeasurement * unitOfMeasurement) throw(DAOException){int code=unitOfMeasurement->getCode();char arr[101];if(code<=0) {sprintf(arr,"Invalid code : %d",code);throw DAOException(string(arr));}const string vTitle=unitOfMeasurement->getTitle();string title=trimmed(vTitle);if(title.length()==0){throw DAOException("Title required, length is zero");}if(title.length()>50){throw DAOException("Title length cannot exceed 50");}sqlite3 *db;char sql[1001];char *errorMessage=NULL;int result=sqlite3_open("uom.db",&db);if(result!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}sprintf(sql,"update UnitOfMeasurement set title='%s' where code=%d;",title.c_str(),code);result=sqlite3_exec(db,sql,NULL,NULL,&errorMessage);if(result!=SQLITE_OK){sprintf(arr,"Unable to update record reason : %s\n",errorMessage);sqlite3_free(errorMessage);sqlite3_close(db);throw DAOException(string(arr));}sqlite3_close(db);}void UnitOfMeasurementDAO::remove(int code) throw(DAOException){char arr[101];if(code<=0) {sprintf(arr,"Invalid code : %d",code);throw DAOException(string(arr));}sqlite3 *db;char sql[1001];char *errorMessage=NULL;int result=sqlite3_open("uom.db",&db);if(result!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}sprintf(sql,"delete from UnitOfMeasurement where code=%d;",code);result=sqlite3_exec(db,sql,NULL,NULL,&errorMessage);if(result!=SQLITE_OK){sprintf(arr,"Unable to delete record reason : %s\n",errorMessage);sqlite3_free(errorMessage);sqlite3_close(db);throw DAOException(string(arr));}sqlite3_close(db);}abc::IUnitOfMeasurement * UnitOfMeasurementDAO::getByCode(int code) throw(DAOException){if(code<=0){throw DAOException("Code should be greater than zero");}sqlite3 *db;char sql[1001];char arr[101];char *errorMessage=NULL;int result=sqlite3_open("uom.db",&db);if(result!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}abc::IUnitOfMeasurement *unitOfMeasurement;unitOfMeasurement=new UnitOfMeasurement;sprintf(sql,"select * from  UnitOfMeasurement where code=%d;",code);result=sqlite3_exec(db,sql,dataHandler,(void*)unitOfMeasurement,&errorMessage);if(result!=SQLITE_OK){sprintf(arr,"Unable to fetch record reason : %s\n",errorMessage);sqlite3_free(errorMessage);sqlite3_close(db);throw DAOException(string(arr));}if(unitOfMeasurement->getCode()==0){sprintf(arr,"Invalid code : %d",code);throw DAOException(string(arr));}sqlite3_close(db);return unitOfMeasurement;}abc::IUnitOfMeasurement * UnitOfMeasurementDAO::getByTitle(string title) throw(DAOException){string vTitle=trimmed(title);if(vTitle.length()==0){throw DAOException("Title required, length is zero");}if(vTitle.length()>50){throw DAOException("Title length cannot exceed 50");}sqlite3 *db;char sql[1001];char arr[101];char *errorMessage=NULL;int result=sqlite3_open("uom.db",&db);if(result!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}abc::IUnitOfMeasurement *unitOfMeasurement;unitOfMeasurement=new UnitOfMeasurement;sprintf(sql,"select * from  UnitOfMeasurement where title='%s';",title.c_str());result=sqlite3_exec(db,sql,dataHandler,(void*)unitOfMeasurement,&errorMessage);if(result!=SQLITE_OK){sprintf(arr,"Unable to fetch record reason : %s\n",errorMessage);sqlite3_free(errorMessage);sqlite3_close(db);throw DAOException(string(arr));}if(compareStringIgnoreCase((unitOfMeasurement->getTitle()).c_str(),string("").c_str())==0){sprintf(arr,"Invalid title : %s",title.c_str());throw DAOException(string(arr));}sqlite3_close(db);return unitOfMeasurement;}forward_list<abc::IUnitOfMeasurement *> *UnitOfMeasurementDAO::getAll() throw(DAOException){sqlite3 *db;char *errorMessage=NULL;int resultCode;char arr[1001];resultCode=sqlite3_open("uom.db",&db);if(resultCode!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}forward_list<abc::IUnitOfMeasurement *> *list;list=new forward_list<abc::IUnitOfMeasurement *>;resultCode=sqlite3_exec(db,"select * from UnitOfMeasurement",rowHandler,(void*)list,&errorMessage);if(resultCode!=SQLITE_OK){sprintf(arr,"Unable to fetch data, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}sqlite3_close(db);return list;}int UnitOfMeasurementDAO::getCount() throw(DAOException){sqlite3 *db;char *errorMessage=NULL;int resultCode;char sql[1001];char arr[101];resultCode=sqlite3_open("uom.db",&db);if(resultCode!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}int count;sprintf(sql,"select count(*) from UnitOfMeasurement;");resultCode=sqlite3_exec(db,sql,countHandler,(void*)&count,&errorMessage);if(resultCode!=SQLITE_OK){sprintf(arr,"Unable to fetch data, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}sqlite3_close(db);return count;}int UnitOfMeasurementDAO::codeExists(int code) throw(DAOException){if(code<=0){throw DAOException("Code should be greater than zero");}sqlite3 *db;char sql[1001];char arr[101];char *errorMessage=NULL;int result=sqlite3_open("uom.db",&db);if(result!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}abc::IUnitOfMeasurement *unitOfMeasurement;unitOfMeasurement=new UnitOfMeasurement;sprintf(sql,"select * from  UnitOfMeasurement where code=%d;",code);result=sqlite3_exec(db,sql,dataHandler,(void*)unitOfMeasurement,&errorMessage);if(result!=SQLITE_OK){sprintf(arr,"Unable to fetch record reason : %s\n",errorMessage);sqlite3_free(errorMessage);sqlite3_close(db);throw DAOException(string(arr));}if(unitOfMeasurement->getCode()==0){return false;}delete unitOfMeasurement;sqlite3_close(db);return true;}int UnitOfMeasurementDAO::titleExists(string title) throw(DAOException){string vTitle=trimmed(title);if(vTitle.length()==0){throw DAOException("Title required, length is zero");}if(vTitle.length()>50){throw DAOException("Title length cannot exceed 50");}sqlite3 *db;char sql[1001];char arr[101];char *errorMessage=NULL;int result=sqlite3_open("uom.db",&db);if(result!=SQLITE_OK){sprintf(arr,"Unable to connect to uom.dat, reason %s\n",sqlite3_errmsg(db));sqlite3_close(db);throw DAOException(string(arr));}abc::IUnitOfMeasurement *unitOfMeasurement;unitOfMeasurement=new UnitOfMeasurement;sprintf(sql,"select * from  UnitOfMeasurement where title='%s';",title.c_str());result=sqlite3_exec(db,sql,dataHandler,(void*)unitOfMeasurement,&errorMessage);if(result!=SQLITE_OK){sprintf(arr,"Unable to fetch record reason : %s\n",errorMessage);sqlite3_free(errorMessage);sqlite3_close(db);throw DAOException(string(arr));}if(compareStringIgnoreCase((unitOfMeasurement->getTitle()).c_str(),string("").c_str())==0){return false;}delete unitOfMeasurement;sqlite3_close(db);return true;}